// Generated by ChatGPT because i'm too dumb (but i fixed it up)
// Used by colourerBatch.js

const ffmpeg = require('fluent-ffmpeg');
const Vibrant = require('node-vibrant');
const { getVideoDurationInSeconds } = require('get-video-duration');
const { PassThrough } = require('stream');
const sharp = require('sharp');
const pLimit = require('p-limit');

const CONCURRENCY = 8;

async function extractFrameAsBuffer(videoPath, timeInSec) {
  return new Promise((resolve, reject) => {
    const stream = new PassThrough();
    const buffers = [];

    ffmpeg(videoPath)
      .seekInput(timeInSec)
      .frames(1)
      .format('image2')
      .outputOptions('-vframes', '1')
      .outputFormat('image2pipe')
      .output(stream)
      .on('error', reject)
      .run();

    stream.on('data', (chunk) => buffers.push(chunk));
    stream.on('end', () => resolve(Buffer.concat(buffers)));
  });
}

async function getVibrantColorFromBuffer(imageBuffer) {
  const resizedBuffer = await sharp(imageBuffer).resize(200, 200).jpeg().toBuffer();
  const palette = await Vibrant.from(resizedBuffer).getPalette();
  const color = palette.Vibrant || palette.LightVibrant || palette.Muted;
  return color ? color.getHex() : '#000000';
}

module.exports = (inputVideo, amount = 50) => {
  return new Promise(async (r) => {
    const duration = await getVideoDurationInSeconds(inputVideo);
    const roundedDuration = Math.floor(duration);
    const limit = pLimit(CONCURRENCY);

    const jobs = [];
    const timePer = duration / amount

    console.log(`Analyzing ${roundedDuration} seconds of video using concurrency=${CONCURRENCY}...`);

    for (let t = 0; t < roundedDuration; t += timePer) {
      jobs.push(limit(async () => {
        try {
          const frameBuffer = await extractFrameAsBuffer(inputVideo, t);
          const hexColor = await getVibrantColorFromBuffer(frameBuffer);
          return { time: Math.round(t), color: hexColor };
        } catch (err) {
          console.error(`Failed at t=${t}s:`, err.message);
          return { time: Math.round(t), color: '#000000' };
        }
      }));
    }

    const results = await Promise.all(jobs);

    const sortedColors = results
      .sort((a, b) => a.time - b.time)
      .map(r => r.color);

    r([timePer, sortedColors]);
  })
};
