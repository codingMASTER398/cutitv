// Generated by Gemini because i'm too dumb
// Used by beatBatch.js to calculate beats.


// Import necessary Node.js modules
const ffmpeg = require('fluent-ffmpeg');
const path = require('path');
const fs = require('fs');
const os = require('os'); // For temporary directory
const { exec } = require('child_process'); // To execute external commands like aubiotrack

/**
 * Extracts the audio track from an MP4 video file.
 * This is an internal helper function for the module.
 *
 * @param {string} videoPath - The path to the input MP4 video file.
 * @param {string} audioOutputPath - The path where the extracted audio file will be saved.
 * @returns {Promise<string>} A promise that resolves with the path to the extracted audio file on success, or rejects on error.
 */
function extractAudio(videoPath, audioOutputPath) {
    console.log(`[Audio Extraction] Starting from: ${videoPath}`);
    console.log(`[Audio Extraction] Saving to: ${audioOutputPath}`);

    return new Promise((resolve, reject) => {
        ffmpeg(videoPath)
            .noVideo() // Only process the audio stream
            .audioCodec('pcm_s16le') // Use PCM signed 16-bit little-endian for WAV (uncompressed, good for analysis)
            .audioChannels(1) // Mono channel is often sufficient for beat detection
            .audioFrequency(44100) // Standard audio frequency
            .toFormat('wav') // Output in WAV format
            .save(audioOutputPath)
            .on('end', () => {
                console.log('[Audio Extraction] Finished successfully.');
                resolve(audioOutputPath);
            })
            .on('error', (err) => {
                console.error(`[Audio Extraction] Error: ${err.message}`);
                reject(err);
            });
    });
}

/**
 * Performs beat detection using the 'aubiotrack' command-line tool.
 * This function requires 'aubio' to be installed and accessible in your system's PATH.
 *
 * @param {string} audioFilePath - The path to the WAV audio file to analyze.
 * @param {object} [aubioOptions={}] - An optional object containing aubiotrack command-line options.
 * Common options include:
 * - `B`: Beat tracking algorithm (e.g., 'default', 'specdiff', 'hfc', 'complex', 'phase'). Default is 'default'.
 * - `s`: Silence threshold (e.g., '0.1' for quieter sounds).
 * - `m`: Minimum tempo in BPM (e.g., '60').
 * - `M`: Maximum tempo in BPM (e.g., '240').
 * - `a`: Onset detection algorithm (e.g., 'default', 'hfc', 'complex', 'phase', 'mkl').
 * - `t`: Output time format (0 for seconds, 1 for samples, 2 for frames). Always 0 for this module.
 * @returns {Promise<Array<{second: number, millisecond: number}>>} A promise that resolves with an array of detected beat timestamps.
 * @throws {Error} If 'aubiotrack' command fails or its output cannot be parsed.
 */
async function analyzeAudioForBeatsWithAubio(audioFilePath, aubioOptions = {}) {
    console.log(`[Aubio Analysis] Starting beat detection for: ${audioFilePath}`);

    return new Promise((resolve, reject) => {
        // Build the aubiotrack command with dynamic options
        let command = `aubiotrack "${audioFilePath}"`;

        // Add options if provided
        for (const key in aubioOptions) {
            if (aubioOptions.hasOwnProperty(key)) {
                // Special handling for '-t' to ensure it's always 0 (seconds)
                if (key === 't') {
                    command += ` -t 0`;
                } else {
                    command += ` -${key} ${aubioOptions[key]}`;
                }
            }
        }

        // Ensure output is always in seconds, overriding any user-provided -t
        if (!aubioOptions.t) { // Only add if not already explicitly handled above
             command += ` -t 0`;
        }


        console.log(`[Aubio Analysis] Executing command: ${command}`);

        exec(command, (error, stdout, stderr) => {
            if (error) {
                console.error(`[Aubio Analysis] Error executing aubiotrack: ${error.message}`);
                console.error(`[Aubio Analysis] Stderr: ${stderr}`);
                return reject(new Error(`AubioTrack command failed: ${stderr || error.message}`));
            }
            if (stderr) {
                // aubiotrack sometimes outputs warnings to stderr, but still provides results to stdout
                console.warn(`[Aubio Analysis] AubioTrack stderr: ${stderr.trim()}`);
            }

            const beatTimestamps = [];
            // Split stdout by new line and filter out empty lines
            const lines = stdout.split('\n').filter(line => line.trim() !== '');

            lines.forEach(line => {
                const totalSeconds = parseFloat(line.trim());
                if (!isNaN(totalSeconds)) {
                    const second = Math.floor(totalSeconds);
                    const millisecond = Math.round((totalSeconds - second) * 1000);
                    beatTimestamps.push({ second, millisecond });
                }
            });

            console.log('[Aubio Analysis] Completed.');
            resolve(beatTimestamps);
        });
    });
}

/**
 * Analyzes an MP4 video file to detect musical beats and returns their timestamps.
 * This function extracts the audio and then uses the 'aubiotrack' tool for beat detection.
 *
 * @param {string} videoFilePath - The absolute path to the input MP4 video file.
 * @param {object} [aubioOptions={}] - Optional aubiotrack command-line options to fine-tune detection.
 * See `analyzeAudioForBeatsWithAubio` for common options.
 * @returns {Promise<Array<{second: number, millisecond: number}>>} A promise that resolves with an array of detected beat timestamps.
 * Each timestamp is an object like `{ second: number, millisecond: number }`.
 * @throws {Error} If the video file does not exist, audio extraction fails, or aubiotrack encounters an issue.
 */
async function getBeatTimestamps(videoFilePath, aubioOptions = {}) {
    if (!fs.existsSync(videoFilePath)) {
        throw new Error(`Input video file not found at: ${videoFilePath}`);
    }

    // Create a temporary file path for the extracted audio
    // Using a unique name to avoid conflicts if multiple calls are made simultaneously
    const tempAudioFileName = `extracted_audio_${Date.now()}_${Math.random().toString(36).substring(2, 8)}.wav`;
    const tempAudioPath = path.join(os.tmpdir(), tempAudioFileName);

    try {
        // Step 1: Extract audio from the video
        const extractedAudioFile = await extractAudio(videoFilePath, tempAudioPath);

        // Step 2: Analyze the extracted audio for beats using Aubio with provided options
        const beatTimestamps = await analyzeAudioForBeatsWithAubio(extractedAudioFile, aubioOptions);

        return beatTimestamps;
    } catch (error) {
        console.error(`[getBeatTimestamps] An error occurred: ${error.message}`);
        throw error; // Re-throw the error to the caller
    } finally {
        // Clean up the temporary audio file
        if (fs.existsSync(tempAudioPath)) {
            fs.unlink(tempAudioPath, (err) => {
                if (err) console.error(`[Cleanup] Error deleting temporary audio file: ${err.message}`);
                else console.log(`[Cleanup] Cleaned up temporary audio file: ${tempAudioPath}`);
            });
        }
    }
}

// Export the main function for use as a module
module.exports = {
    getBeatTimestamps
};
